> 大家好，这里是好评笔记，公主号：Goodnote，专栏文章私信限时Free。本文详细介绍了三种最火热的基于Transformer架构的NLP模型：GPT、BERT和T5。
> 

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c70ecc97c2fa4366bc5dcbeb70256488.png#pic_center)


> @[toc]

GPT（Generative Pre-trained Transformer）、BERT（Bidirectional Encoder Representations from Transformers）和T5（Text-To-Text Transfer Transformer）都是**基于Transformer架构**的自然语言处理模型，但它们在结构、训练方式和应用场景上有显著的区别。

# 一、GPT
GPT的全称是“**生成式预训练模型**”，其主要设计思想是通过大规模的语言建模任务进行预训练，并通过微调来解决下游的具体任务。GPT的结构特点如下：

1. **Transformer解码器架构**：
   - GPT使用的是Transformer的**解码器（Decoder）** 部分。这个架构主要由自注意力机制（self-attention）和前馈神经网络（Feedforward Neural Networks）组成。解码器可以处理序列数据，生成新的序列，因此适合生成任务，如文本生成。
   
2. **单向（Autoregressive）语言模型**：
   - GPT是**单向**模型，**即只能从左到右生成词语**。输入的每个词只能依赖于前面的词，不能看后面的词。这种设计使得它在处理语言生成任务时很有效，但在理解句子整体时略显不足。
   
3. **预训练任务**：
   - 预训练阶段，GPT通过**自回归的语言建模任务**进行训练，**目标是预测句子中下一个词**。然后，针对不同任务（如文本分类、问答等）进行微调。

4. **适合生成任务**：
   - GPT强大的生成能力，自回归的生成文本，每次生成一个词并将其作为输入，再生成下一个词。这种方式使它特别适合生成连贯的段落和长文本。

### 为何采用单向Transformer？
使用的是**解码器**，**自回归生成模式**。
使用了**Masked Self-Attention**(所谓Masked，即遮蔽的意思)，即句子中的每个词，都**只能对包括自己在内的前面所有词进行Attention**，这就是单向Transformer。


## 基于Transformer的优化
除了仅使用解码器堆叠的架构、未来遮蔽（自回归语言模型）外，还做了下面的优化。

### 层归一化提前
   - 在标准 Transformer 中，层归一化（Layer Normalization）通常放在残差连接和前馈网络之后，而 GPT 将层归一化放在残差连接之前，称为 **Pre-Layer Normalization**。
   - 这种调整有助于在深层网络中保持梯度的稳定性，并减轻训练深度模型时梯度消失的问题。

### RoPE旋转位置编码
   - GPT 最初使用的绝对位置编码（如 GPT-2 和 GPT-3 中使用的简单绝对位置编码），后续的 GPT-4 等新版本采用了 **混合位置编码** 或 **旋转位置编码** 等技术，使得位置编码对更长序列具有更好的泛化性。
   - 这些改进帮助模型在长文本和复杂结构的文本上表现更好。

RoPE旋转位置编码参考：[深度学习笔记——常见的Transformer位置编码](https://blog.csdn.net/haopinglianlian/article/details/144021458)
### 后续改进：指令微调和人类反馈强化学习（RLHF）
   - 在 GPT-3.5 和 GPT-4 中，引入了 **指令微调** 和 **基于人类反馈的强化学习（RLHF）**。通过在人类指令和偏好的数据上微调模型，使其在对话、问答等任务中更符合用户意图。
   - RLHF 训练方法提高了生成文本的自然性和用户满意度，使得模型在提供建议和解释复杂问题时更加精确。

# 二、BERT
BERT全称是“Transformers的双向编码表示”，它是为了**提升语言理解任务**（如文本分类、问答等）的效果而设计的。BERT的结构特点如下：

1. **Transformer编码器架构**：
   - BERT使用的是Transformer的**编码器（Encoder）**部分。与解码器不同，编码器主要用于表示输入序列中的每个词，并关注该词与序列中其他**词之间的关系**。

2. **双向（Bidirectional）语言模型**：
   - BERT是一种**双向**模型，即在处理某个词时，既可以考虑到该词左边的词，也可以考虑到右边的词。通过这种双向机制，BERT在理解句子的**全局语义上有显著优势**。

3. **预训练任务**：
   - BERT的预训练主要基于两项任务：
     - **Masked Language Model (MLM)**：随机遮盖输入序列中的部分词语，然后**让模型预测被遮盖的词**。这使得模型在训练过程中学会了利用上下文信息。
     - **Next Sentence Prediction (NSP)**：**预测两句话是否相邻**。这个任务增强了模型理解句间关系的能力。

4. **适合理解任务**：
   - 由于BERT的双向特性，它在处理语言理解任务时表现极为出色，如文本分类、问答系统、命名实体识别等。

## 预训练任务
**MLM（Masked Language Model）** 和 **NSP（Next Sentence Prediction）** 是 BERT（Bidirectional Encoder Representations from Transformers）模型的两种预训练任务。它们的设计目的是**帮助BERT 更好地理解语言结构和语义关系**，尤其是在下游自然语言处理任务（如分类、问答、命名实体识别等）中增强模型的表现。下面分别介绍这两个任务的原理和目的。
## 1. MLM（Masked Language Model）——掩码语言模型
### 1.1 原理
MLM 通过**随机掩盖**输入序列中的一些词，并要求模型通过上下文信息预测这些被掩盖的词，来**帮助模型学习上下文中的词语关系**。
### 1.2 步骤
1. **输入序列**：BERT 接收输入序列，如一个句子或者一段文本。
2. **随机掩盖部分词汇**：BERT 随机选择输入序列中**15%** 的词，并将它们替换为特殊的 [MASK] 标记。
3. **模型预测被掩盖的词**：模型的目标是**基于上下文**（即未被掩盖的其他词），预测被 [MASK] 掩盖的词。BERT 通过**最大化被掩盖词的正确预测概率**来进行训练。
### 1.3 掩码的机制
被**掩盖的词**中：
- **80%**：用 [MASK] 代替这个词。
- **10%**：随机替换为词汇表中的其他词。
- **10%**：保持词语不变。

这种机制是为了让模型不仅能学会对 [MASK] 标记进行预测，还能在下游任务中更好地**处理实际出现的词**，因为在推理阶段不会有 [MASK] 标记。
### 1.4 MLM 的作用
- **双向上下文学习**：通过预测被掩盖的词，BERT 能够同时利用词的左侧和右侧上下文进行训练，**学习语言的全局信息**。这使得 BERT 成为双向语言模型，能够捕捉到句子中的前后依赖关系。
- **语言理解增强**：MLM 帮助 BERT **学习丰富的词汇表示和句子结构**，使其在处理复杂的自然语言理解任务时具备更强的能力。
## 2. NSP（Next Sentence Prediction）——下一句预测
### 2.1 原理
NSP 目的是**帮助模型理解句子之间的关系**，尤其是在涉及多个句子上下文的任务中，如阅读理解、句子推理等。具体来说，NSP 任务要求模型**判断两个句子是否在原文中是连续的**。
### 2.2 步骤
1. **输入两句话**：在训练过程中，模型会被输入两个句子（句子 A 和句子 B）。
2. **判断句子关系**：
   - **50% 的情况下**：句子 B 是句子 A 的实际后续句子，即**这两个句子在原始文本中是连续的**。
   - **另外 50% 的情况下**：句子 B 是随机选择的一个句子，**两个句子没有关系**。
3. **模型预测**：BERT 的任务是判断句子 B 是否为句子 A 的真实后续句子。这一任务通过**在BERT的 [CLS] 标记位置添加一个分类层来完成**，输出是 "是" 或 "否" 的二分类问题。
### 2.3 NSP 的作用
- **学习句子间的语义关系**：通过 NSP 任务，BERT 能够理解句子之间的逻辑顺序和语义关联。这对于多句子的自然语言推理、文档级别的任务、问答等场景非常重要。
- **增强文本的全局理解**：NSP 不仅帮助模型理解单个句子的上下文，还让模型能够推理出跨句子的语义关系，从而在一些任务（如文本相似度、上下文依赖问答等）中表现更好。
### 2.4 NSP 的局限性与改进
- **改进版本（RoBERTa）**：在后来的研究中，例如 RoBERTa 模型中，研究者发现 NSP 任务对某些下游任务的提升有限，因此 RoBERTa 移除了 NSP 任务，只使用了更大规模的语料库和更长的训练时间，但仍然在许多任务中取得了更好的性能。
## 3. MLM 和 NSP 的结合
- **MLM 和 NSP 结合训练**：
  - 通过 MLM，学习了如何**从局部上下文中预测词语**，从而增强语言的理解能力；
  - 通过 NSP，学会了如何**理解句子之间的逻辑顺序和语义联系**，从而提升了其在跨句子任务上的表现。

- **MLM 和 NSP 的相互作用**：**MLM 关注单个句子的上下文**，而 **NSP 通过跨句子预测**使模型掌握了多句子理解的能力。它们共同作用，使得 BERT 在各类自然语言处理任务（如文本分类、问答系统、文本生成等）中表现优异。
## 4. MLM和NSP任务对比
| **任务**                 | **MLM（Masked Language Model）**                        | **NSP（Next Sentence Prediction）**                 |
|-------------------------|-------------------------------------------------------|---------------------------------------------------|
| **目的**                 | 预测被掩盖的词语，帮助模型**学习上下文中的词语关系**        | 判断两句话是否在原文中连续，**学习句子间的语义关系**   |
| **输入**                 | 一个被随机掩盖词语的句子                              | 两个句子 A 和 B                                   |
| **输出**                 | 预测掩盖词的正确词语                                  | 判断句子 B 是否是句子 A 的真实后续句               |
| **任务目标**             | 学习**句子内部**的词语依赖关系，增强词表示                 | 学习**句子之间**的语义联系，增强句子对的理解           |
| **对模型的作用**         | 强化模型对上下文的理解能力，**提高词表示的质量**            | **增强句子间关系的推理能力**，适合多句子任务     |
| **局限性与改进**         | 使用掩码词语导致预测任务偏离真实场景                    | 对部分任务贡献较小（如在 RoBERTa 中被移除）        |


## 基于Transformer的优化
除了双向编码器的架构、MLM和NSP的预训练任务外，还做了下面的优化。
###  [CLS] 和 [SEP] 标记
   - BERT 引入了特殊的 **[CLS]** 和 **[SEP]** 标记：
     - **[CLS] 标记**：每个输入序列的开头都包含一个 [CLS] 标记，它的输出**表示整个序列的聚合信息**，常用于**分类**任务。
     - **[SEP] 标记**：**用于分隔两个句子**，特别是在句子对任务中，例如句子间的关系判断。
   - 这种输入表示方式便于模型处理单句和句子对任务，同时在预训练和微调过程中保持一致。

### GELU激活函数
BERT 使用的是 GELU 激活函数，而不是传统 Transformer 的 ReLU。GELU 的平滑性和更好的梯度流动特性，使其在深度语言模型中表现更优，提升了模型在复杂自然语言任务上的性能。


# 三、GPT与BERT的主要区别

| 特性            | **GPT**                                    | **BERT**                                   |
|-----------------|--------------------------------------------|--------------------------------------------|
| **架构**        | 基于 Transformer **解码器**（**单向**）         | 基于 Transformer **编码器**（**双向**）         |
| **方向性**      | 单向（从左到右，自回归生成）               | 双向（同时考虑左侧和右侧上下文）           |
| **预训练任务**  | **自回归语言模型**                             | 掩码语言模型（**MLM**）和下一句预测（**NSP**）      |
| **应用领域**    | 文本生成、对话系统、故事生成等生成任务     | 自然语言理解任务，如分类、NER、问答系统    |
| **模型强项**    | 强大的**生成能力**，适合长文本生成             | 强大的**语义理解能力**，适合分类、句子配对等   |

- **GPT**主要用于**生成任务**，基于Transformer的解码器，单向训练。
- **BERT**用于**理解任务**，基于Transformer的编码器，双向训练。

GPT和BERT分别在文本生成和文本理解上具有领先的性能，各自适用于不同的自然语言处理任务。




# 四、T5
T5（Text-To-Text Transfer Transformer）是 Google 提出的一个**通用NLP模型**，其核心思想是**将所有 NLP 任务转换为“文本到文本”（Text-to-Text）的问题**。**统一 NLP 任务格式**，提升了模型在多任务上的通用性和泛化能力。

## 一、T5 的设计理念
T5 的设计目标是**构建一个通用的NLP任务模型**。T5 团队提出了一种框架，把不同任务（例如翻译、分类、问答等）统一为文本输入到文本输出的格式。因此，不论任务的复杂度和类型如何，所有任务都能在相同的文本格式下进行处理。这一设计带来了以下优点：

1. **任务统一化**：通过将**所有任务转换为文本到文本问题**，T5 不需要针对不同任务设计特殊的头部或架构改动，提升了模型的通用性。
2. **灵活性强**：T5 的文本到文本框架能处理大量任务，使得模型可以在多任务环境下高效共享知识。
3. **简化任务适配**：对新任务而言，只需将任务描述和目标文本格式化为输入输出对，就可以轻松融入到 T5 的框架中。
## 二、T5 的架构

T5 使用**完整的 Transformer 序列到序列（Seq2Seq）架构**，包括编码器和解码器，适合处理生成和理解类任务。

- **编码器（Encoder）**：将输入**文本转化为编码表示**，编码器通过多层自注意力（Self-Attention）和前馈神经网络（Feed-Forward Network）模块，从输入中学习上下文信息。
  
- **解码器（Decoder）**：接收编码器生成的表示，基于解码器的自回归特性逐步生成输出文本。解码器不仅包含自注意力层，还包括与**解码器-编码器之间的跨注意力**（Cross-Attention）层，从而能够在生成时同时关注到输入和前一步生成的内容。

这种 Seq2Seq 结构使得 T5 适合处理机器翻译、文本生成、问答等需要生成序列的任务，同时也可以通过指定格式执行理解类任务，如文本分类和情感分析。

## 三、T5 的预训练任务及过程
T5 通过**无监督的预训练任务**掌握语言知识，之后在**具体任务上微调**。其预训练任务是**一种“填空任务”的变体**，称为**Span Corruption**，核心目的是让模型在大规模无监督文本数据上学习语言模式和上下文理解。
### 1.   Span Corruption 填空任务 
在预训练中，T5 通过**遮蔽输入中的若干词语片段**（spans）并要求**模型恢复这些被遮蔽的内容**。这一任务过程如下：

1. **遮蔽片段**：在一段输入文本中，随机选择若干**不连续**的词片段，这些词片段长度不一，通常每个片段包括几个词。被选择的词片段用**特定的占位符标记“<extra_id_X>”替换**。
   
2. **生成目标**：模型的目标是**生成这些被遮蔽的词片段的完整内容**。例如，假设输入是“我今天买了<extra_id_0>，还<extra_id_1>。”，目标输出可能是“苹果”对应“<extra_id_0>”，而“去了图书馆”对应“<extra_id_1>”。

3. **自回归生成**：解码器部分需要**依次生成遮蔽的词片段**，训练时通过预测缺失内容来学习词语之间的相关性。

#### 与 BERT 的 MLM的差异点
这种方式**相较于 BERT 的 MLM**（Masked Language Model）有几个优势：

| 特点                  | **T5 的 Span Corruption（片段遮蔽任务）**                               | **BERT 的 MLM（Masked Language Modeling）**               |
|-----------------------|-------------------------------------------------------------------------|-----------------------------------------------------------|
| **遮蔽方式**         | 遮蔽**不连续的词片段**（spans），每个片段包含多个连续词                      | 随机遮蔽单个词（15%的词），**每次只遮蔽单个词或字符**          |
| **遮蔽标记**         | 使用**统一的占位符**（如 `<extra_id_0>`）替代整个片段，每个片段有唯一标识符  | 每个被遮蔽词用 **`[MASK]` 替换**，但只遮蔽单词，无区分标识    |
| **预测目标**         | 要求模型生成被遮蔽的整个词片段，**生成的片段**可以**包含多个词**                 | 要求模型预测被掩盖的**单个词**，预测是单词级别的              |
| **上下文建模**       | 通过片段遮蔽，模型在预测时需要**考虑更长的上下文**，能更好地捕获片段之间的关系 | 通过单词级遮蔽，模型关注**局部上下文**，对长距离依赖支持较弱  |
| **生成与理解能力**   | 同时提升**生成**和**理解**能力，尤其适合生成类任务                               | 主要提升**理解能力**，适合分类、匹配等理解类任务              |
| **任务形式**         | 生成被遮蔽片段的完整序列，适合文本到文本的生成和理解任务                | 预测单词，适合文本理解任务                                |
| **优势**             | - 强化长距离上下文的理解<br>- 提升生成任务效果，适合序列生成类任务<br>- 对片段关系建模良好 | - 双向上下文对理解类任务支持好<br>- 实现较简单<br>- 更适合单词理解 |
| **局限性**           | - 训练更复杂，计算开销更大<br>- 依赖更复杂的数据格式化<br>- 不适合仅依赖单词理解的任务 | - 不适合生成任务<br>- 仅单词级别遮蔽，对长依赖关系支持弱 |

**详细对比分析：**
T5 的 Span Corruption 增强了模型的生成和理解能力，适合**多任务和生成任务**；BERT 的 MLM 更偏向理解类任务，适合分类、情感分析等应用。
   - **增强生成能力**：T5 的 Span Corruption 任务可以更好地提升生成能力，因为模型在训练中需要生成连续的片段，而非单独的词。
   - **处理长依赖关系**：T5 的设计通过恢复长短不一的片段，可以帮助模型更好地理解上下文中的长距离关系。
### 2.  预训练过程 
#### 预训练过程
1. **选择遮蔽片段**：在输入文本中，随机选择不连续的片段（spans），并对每个片段使用一个特殊的占位符（如 `<extra_id_0>`, `<extra_id_1>` 等）替换。每个被遮蔽片段长度不一，这样的设计可以模拟现实中的缺失文本情况。

   - 例如，原始输入句子是：“The quick brown fox jumps over the lazy dog.”
   - 遮蔽后的输入可能是：“The quick <extra_id_0> jumps <extra_id_1> dog.”

2. **构建目标输出**：模型的输出目标是生成所有被遮蔽的片段内容。模型需要生成 `<extra_id_0>` 为 "brown fox"，`<extra_id_1>` 为 "over the lazy"。

   - 输入：“The quick <extra_id_0> jumps <extra_id_1> dog.”
   - 输出：“<extra_id_0> brown fox <extra_id_1> over the lazy”

3. **自回归生成**：模型通过解码器依次生成每个遮蔽片段的内容。由于生成是自回归的，模型在生成一个片段时只能看到前面已经生成的内容，增强了其生成能力。

## 四、微调（Fine-tuning）

在完成无监督的预训练之后，T5 通过微调适应具体的下游任务。在微调阶段，任务需要按照预定义的格式转化为文本输入和输出。例如：

- **翻译任务**：格式化输入：“translate English to French: The cat is on the mat”，目标输出为对应的法语翻译：“Le chat est sur le tapis”。
- **问答任务**：格式化输入：“question: Where does the cat sit? context: The cat is on the mat”，目标输出为答案：“on the mat”。
- **文本分类任务**：格式化输入：“sentiment analysis: I love this movie”，目标输出为情感分类结果，如“positive”。
  
通过这样的格式化方法，T5 可以适应几乎所有的 NLP 任务而无需改变架构。

## 五、T5 的变体

T5 提供了多个不同参数量的模型变体以适应不同的任务需求和计算资源条件：

1. **T5-Small**（3000 万参数）
2. **T5-Base**（2.2 亿参数）
3. **T5-Large**（7.7 亿参数）
4. **T5-3B**（30 亿参数）
5. **T5-11B**（110 亿参数）

用户可以根据任务的复杂性和硬件资源选择适合的变体，以平衡模型性能与计算资源需求。

## 六、T5 的优势与局限性
**优势：**
1. **任务统一化**：T5 的文本到文本框架使得任务的格式和数据处理变得简单，不需要为不同任务单独设计架构或头部。
2. **多任务泛化能力强**：通过在不同任务上的共享训练，T5 可以高效地在多个任务上表现优异。
3. **生成和理解任务兼顾**：T5 的架构不仅适合生成任务（如翻译、摘要），也适合理解任务（如分类、情感分析）。

**局限性：**

1. **计算开销大**：由于 T5 需要通过自回归生成输出，尤其在长文本生成任务上，计算量比 BERT 更大。
2. **任务依赖格式化**：虽然 T5 的框架通用，但不同任务的格式化仍然需要额外的预处理。
3. **大模型参数**：T5 的大参数变体（如 11B）在训练和推理时需要大量计算资源，通常对硬件要求较高。

## 七、T5 的应用场景

由于 T5 采用了统一的“文本到文本”框架，几乎所有 NLP 任务都可以格式化为 T5 处理：

1. **文本生成**：如自动摘要、文章续写等，T5 在生成类任务中表现出色。
2. **文本分类**：通过输入任务说明和待分类文本，T5 可以进行情感分析、主题分类等任务。
3. **机器翻译**：T5 支持多种语言的翻译任务，输入格式化为“translate A to B”即可。
4. **问答系统**：T5 可以根据上下文回答问题，尤其在封闭领域问答任务中效果良好。
5. **填空和完形填空**：适合信息抽取任务或信息补全。
6. **语言理解**：例如文本蕴含、语义相似度判断等，T5 可以通过文本到文本框架轻松处理。

## 八、总结
T5 是一个具备多任务能力的强大 NLP 模型，其“文本到文本”框架使其在理解和生成任务中均表现出色。T5 的设计、预训练和任务转换流程展示了其通用性和灵活性，广泛适用于机器翻译、文本分类、问答和文本生成等多种任务。

## 基于Transformer的优化
除了统一的文本到文本框架（Text-to-Text Framework）、片段掩蔽（Span Corruption）外，还做了下面的优化。
### 相对位置编码（Relative Position Encoding）
   - T5 使用了 **相对位置编码**，而不是传统 Transformer 的绝对位置编码（例如正弦和余弦位置编码）。在 T5 中，位置信息是通过注意力分数中的相对位置偏置来表示的，而不是直接加入到输入嵌入中。
   - 相对位置编码可以更灵活地适应不同长度的序列，使模型在长文本处理和生成任务中具有更好的表现。
### 去掉 Layer Normalization 中的偏置
   - T5 去掉了，这在保持模型性能的前提下简化了模型结构并减少了参数量。
   - 尽管这一改动较小，但在 T5 的大规模训练中，
### 简化的模型结构
   - T5 取消了标准 Transformer 中的额外偏置和层的冗余设计（去除多头自注意力、前馈网络和 Layer Normalization 中的偏置项），简化了编码器-解码器结构，提升了计算效率。
   - 在架构上，T5 保持了标准 Transformer 的堆叠结构，但在参数优化上进行了简化，保证了较少的冗余计算。这种优化有助于减少计算资源的消耗，特别是在分布式训练场景中更为高效。


# 五、T5、BERT 和 GPT 的对比

以下是 T5、BERT 和 GPT 的详细对比总结表格：

| 特点               | **T5（Text-To-Text Transfer Transformer）**               | **BERT（Bidirectional Encoder Representations from Transformers）** | **GPT（Generative Pre-trained Transformer）**        |
|--------------------|-----------------------------------------------------------|---------------------------------------------------------------------|------------------------------------------------------|
| **任务类型**      | 通用：文本**生成和理解**任务                                   | **理解**任务（自然语言理解）                                            | **生成**任务（自然语言生成）                             |
| **模型架构**      | 完整的 Seq2Seq 结构（**编码器 + 解码器**）                      | 仅编码器                                                            | 仅解码器                                             |
| **预训练任务**    | Span Corruption（片段遮蔽任务）：遮蔽词片段并生成完整内容     | Masked Language Modeling + Next Sentence Prediction               | 自回归：给定前 n 个词预测下一个词                     |
| **训练目标**      | 生成被遮蔽片段的完整序列                                    | 预测被掩盖词和判断句子间的关系                                      | 逐词预测下一个词                                     |
| **上下文方向**    | **双向编码器 + 自回归（单向）解码器**                                   | 完全双向                                                            | 单向（从左到右）                                     |
| **生成任务适应性**| 出色，适合生成类任务（如机器翻译、摘要）                    | 不适合生成任务                                                     | 优秀，适合生成类任务（如对话生成、文本生成）         |
| **理解任务适应性**| 良好，可处理情感分析、问答等任务                             | 出色，适合文本分类、命名实体识别等理解任务                          | 较弱，对上下文理解有限                               |
| **多任务适应性**  | 高，多任务能力强，能统一处理生成和理解任务                   | 较低，专注理解任务                                                 | 较低，主要用于生成任务                               |
| **优势**          | - 多任务适应性强，统一框架便于理解和生成任务<br>- 适用于多种 NLP 任务<br>- 生成和理解任务均可胜任 | - 理解任务效果优异<br>- 双向上下文增强对语义理解<br>- 适合分类和实体识别等任务 | - 生成任务中表现出色<br>- 文本生成自然连贯<br>- 适合对话和续写等任务 |
| **局限性**        | - 训练开销大，对计算资源需求高<br>- 需要格式化处理不同任务  | - 不能生成文本<br>- 仅适合理解类任务                               | - 对理解任务表现有限<br>- 单向上下文限制上下文理解   |
| **典型应用**      | - 翻译、摘要生成<br>- 情感分类<br>- 问答系统<br>- 多任务环境 | - 文本分类<br>- 命名实体识别<br>- 情感分析<br>- 句子对分类         | - 对话生成<br>- 文章续写<br>- 自动文本生成           |

### 总结

- **T5**：适用于多任务处理，通过统一的“文本到文本”框架，兼顾生成和理解任务，尤其在需要处理多种任务的环境中表现优异。
- **BERT**：专注理解任务，尤其适合需要双向上下文理解的任务，如文本分类和实体识别等。
- **GPT**：适合生成任务，通过自回归生成自然流畅的文本，擅长对话、续写等任务，但在理解任务上表现较弱。

# 历史文章

## 机器学习

[机器学习笔记——损失函数、代价函数和KL散度](https://blog.csdn.net/haopinglianlian/article/details/143831958?)
[机器学习笔记——特征工程、正则化、强化学习](https://blog.csdn.net/haopinglianlian/article/details/143832118?)
[机器学习笔记——30种常见机器学习算法简要汇总](https://blog.csdn.net/haopinglianlian/article/details/143832321)
[机器学习笔记——感知机、多层感知机(MLP)、支持向量机(SVM)](https://blog.csdn.net/haopinglianlian/article/details/143832552)
[机器学习笔记——KNN（K-Nearest Neighbors，K 近邻算法）](https://blog.csdn.net/haopinglianlian/article/details/143832692)
[机器学习笔记——朴素贝叶斯算法](https://blog.csdn.net/haopinglianlian/article/details/143832781?)
[机器学习笔记——决策树](https://blog.csdn.net/haopinglianlian/article/details/143834363)
[机器学习笔记——集成学习、Bagging（随机森林）、Boosting（AdaBoost、GBDT、XGBoost、LightGBM）、Stacking](https://blog.csdn.net/haopinglianlian/article/details/143834494?)
[机器学习笔记——Boosting中常用算法（GBDT、XGBoost、LightGBM）迭代路径](https://blog.csdn.net/haopinglianlian/article/details/143834628)
[机器学习笔记——聚类算法（Kmeans、GMM-使用EM优化）](https://blog.csdn.net/haopinglianlian/article/details/143834707)
[机器学习笔记——降维](https://blog.csdn.net/haopinglianlian/article/details/143834847)

## 深度学习
[深度学习笔记——优化算法、激活函数](https://blog.csdn.net/haopinglianlian/article/details/143835137)
[深度学习——归一化、正则化](https://blog.csdn.net/haopinglianlian/article/details/143835273)
[深度学习——权重初始化、评估指标、梯度消失和梯度爆炸](https://blog.csdn.net/haopinglianlian/article/details/143835336)
[深度学习笔记——前向传播与反向传播、神经网络（前馈神经网络与反馈神经网络）、常见算法概要汇总](https://blog.csdn.net/haopinglianlian/article/details/143835406)
[深度学习笔记——卷积神经网络CNN](https://blog.csdn.net/haopinglianlian/article/details/143841327)
[深度学习笔记——循环神经网络RNN、LSTM、GRU、Bi-RNN](https://blog.csdn.net/haopinglianlian/article/details/143841402)
[深度学习——Transformer](https://blog.csdn.net/haopinglianlian/article/details/143841447)
[深度学习——3种常见的Transformer位置编码](https://blog.csdn.net/haopinglianlian/article/details/144021458)



